---
title: 'Week 5: Overlap Diagnosis - Suggested Solutions'
author: "Maggie X. Wang"
date: "2026-02-06"
output: html_document
---

Do minority candidates drive minority voter turnout? Keele et al. (2017) examined mayoral elections in Louisiana from 1988 to 2011 and compare differences in Black turnout among elections with a Black candidate and elections with all-white candidates.

Identification challenge: Black candidates are not randomly assigned to elections. Black candidates run in districts with larger Black population shares.

*Citation: Keele, Luke J., Paru R. Shah, Ismail White, and Kristine Kay. "Black candidates and black turnout: A study of viability in louisiana mayoral elections." The Journal of Politics 79, no. 3 (2017): 780-791.*

Download data here: https://github.com/UChicago-pol-methods/PLSC30600/blob/main/data/keele-et-al-2017.dta

Relevant variables:
+ `black`: Whether the candidate is Black (treatment)
+ `blackpop_pct1990`: Percent of voters who are Black (covariate)

```{r}
library(tidyverse)
library(haven)
library(estimatr)
```

```{r}
# Load data
turn <- read_dta("keele-et-al-2017.dta")
```

# 1. Warmup: Diagnose overlap in X-space  

## 1.1 Let's start with the original data - visualize the overlap

```{r}
p_x_overlap_orig <- ggplot(turn, aes(x = blackpop_pct1990, fill = factor(black))) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 30) +
  theme_minimal() +
  labs(
    fill = "Black candidate (D)",
    x = "Black population share (1990)",
    y = "Count",
    title = "Overlap in X-space (Original data)"
  )

print(p_x_overlap_orig)
```

## What if the overlap problem is more egregious?

Here, I am manipulating the support for the covariate to make the treatment more deterministic on the covariate based on a cutoff rule, hence reducing overlap.

```{r}
x_cut <- 0.35
eps   <- 0.03

turn_bad <- turn %>%
  mutate(
    black_det = if_else(blackpop_pct1990 > x_cut, 1L, 0L),
    flip = rbinom(n(), 1, eps),
    black = if_else(flip == 1L, 1L - black_det, black_det)
  )
```

## 1.2 Visualize again and compare

```{r}
p_x_overlap_both <- bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Manipulated (worse overlap)")
) %>%
  ggplot(aes(x = blackpop_pct1990, fill = factor(black))) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 30) +
  facet_wrap(~ dataset, ncol = 1) +
  theme_minimal() +
  labs(
    fill = "Black candidate (D)",
    x = "Black population share (1990)",
    y = "Count",
    title = "Overlap in X-space (Original vs Manipulated)"
  )

print(p_x_overlap_both)
```

# 2. Exercise: Overlap and IPW

## 2.1 Calculate the propensity scores for each dataset and compare their distrubutions

```{r}
ps_orig <- glm(black ~ blackpop_pct1990, data = turn, family = binomial())
ps_bad  <- glm(black ~ blackpop_pct1990, data = turn_bad, family = binomial())

turn <- turn %>%
  mutate(ps_hat = predict(ps_orig, type = "response"),
         w_ate  = if_else(black == 1, 1/ps_hat, 1/(1-ps_hat)))

turn_bad <- turn_bad %>%
  mutate(ps_hat = predict(ps_bad, type = "response"),
         w_ate  = if_else(black == 1, 1/ps_hat, 1/(1-ps_hat)))
```

```{r}
bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Manipulated")
) %>%
  ggplot(aes(x = ps_hat, fill = factor(black))) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 30) +
  facet_wrap(~ dataset, ncol = 1) +
  theme_minimal() +
  labs(fill = "D",
       x = "Estimated propensity score",
       y = "Count",
       title = "Propensity score distributions (Original vs Manipulated)")
```

## 2.2 Obtain IPW weights and compare their distributions

```{r}
# I obtained weights already in the previous part, so just plotting

bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Manipulated")
) %>%
  ggplot(aes(x = w_ate, fill = dataset)) +
  geom_histogram(position = "identity", alpha = 0.4, bins = 60) +
  scale_x_log10() + # log scale for visibility
  theme_minimal() +
  labs(x = "ATE IPW weights (log scale)",
       y = "Count",
       title = "IPW weight distributions (Original vs Manipulated)")
```

## 2.3 Report common support

Recall from lecture slides, a common diagnostic tool for overlap is reporting the share of units outside common support (e.g., pscore < 0.05 or > 0.95).

```{r}
low_cs <- 0.05
high_cs <- 0.95

bind_rows(
  turn %>%
    mutate(dataset = "Original",
           outside = ps_hat < low_cs | ps_hat > high_cs),
  turn_bad %>%
    mutate(dataset = "Near-deterministic",
           outside = ps_hat < low_cs | ps_hat > high_cs)
) %>%
  group_by(dataset) %>%
  summarise(
    n = n(),
    n_outside = sum(outside),
    share_outside = mean(outside),
    .groups = "drop"
  )
```

## 2.4 Using bootstrap, compare the variance of the IPW ATEs using the two datasets

```{r}
set.seed(30600)
B <- 300

ipw_est_one <- function(dat) {
  with(dat, {
    weighted.mean(black_turnout[black == 1], w_ate[black == 1]) -
      weighted.mean(black_turnout[black == 0], w_ate[black == 0])
  })
}

boot_ipw_orig <- replicate(B, {
  idx <- sample.int(nrow(turn), nrow(turn), replace = TRUE)
  ipw_est_one(turn[idx, ])
})

boot_ipw_bad <- replicate(B, {
  idx <- sample.int(nrow(turn_bad), nrow(turn_bad), replace = TRUE)
  ipw_est_one(turn_bad[idx, ])
})

tibble(
  dataset = c("Original", "Manipulated"),
  boot_mean = c(mean(boot_ipw_orig), mean(boot_ipw_bad)),
  boot_sd   = c(sd(boot_ipw_orig), sd(boot_ipw_bad))
)
```

```{r}
# Optional visualization
bind_rows(
  tibble(est = boot_ipw_orig, dataset = "Original"),
  tibble(est = boot_ipw_bad, dataset = "Near-deterministic")
) %>%
  ggplot(aes(x = est, fill = dataset)) +
  geom_density(alpha = 0.35) +
  theme_minimal() +
  labs(
    x = "Bootstrap IPW ATE",
    y = "Density",
    title = "Bootstrap IPW ATE distributions (fixed propensity scores)"
  )
```
# 3. Overlap and Matching

## Nearest-neighbor matching

Hot deck imputation is one way to use propensity score for matching. Nearest-neighbor is another, among many distance-based matching methods. Because the purpose of this exercise is visualization and illustration, I am using nearest-neighbor matching with propensity score distance.

The idea: For each unit, find the most similar unit in the opposite treatment group.

```{r}
nn_dist <- function(dat) {
  D <- dat$black
  ps <- dat$ps_hat
  out <- numeric(length(ps))
  for (i in seq_along(ps)) {
    opp_ps <- ps[D != D[i]]
    out[i] <- if (length(opp_ps) == 0) NA_real_ else min(abs(ps[i] - opp_ps))
  }
  out
}

turn$nn_psdist <- nn_dist(turn)
turn_bad$nn_psdist <- nn_dist(turn_bad)
```

## Visualize the match: propensity score distance

A smaller distance therefore means that the unit has more similar covariates to its nearest neighbor in the opposite treatment group.

```{r}
bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Manipulated")
) %>%
  ggplot(aes(x = nn_psdist, fill = dataset)) +
  geom_density(alpha = 0.4) +
  theme_minimal() +
  labs(x = "Nearest opposite-treatment PS distance",
       y = "Density",
       title = "Nearest-neighbor PS distance: match quality diagnostic")
```

## Evaluate the match: chance of a close match

For each unit, count how many opposite-treatment units are within a certain PS distance. Having more opposite-treatment units is good for matching.

```{r}
caliper <- 0.05

count_close <- function(dat, caliper = 0.05) {
  D <- dat$black
  ps <- dat$ps_hat
  sapply(seq_along(ps), function(i) sum(abs(ps[D != D[i]] - ps[i]) <= caliper))
}

turn$n_close <- count_close(turn, caliper)
turn_bad$n_close <- count_close(turn_bad, caliper)

bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Manipulated")
) %>%
  group_by(dataset) %>%
  summarise(
    share_no_close = mean(n_close == 0),
    share_few_close = mean(n_close <= 2),
    median_close = median(n_close),
    .groups = "drop"
  )
```

```{r}
# Visualize
bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Manipulated")
) %>%
  ggplot(aes(x = n_close, fill = dataset)) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 30) +
  theme_minimal() +
  labs(x = sprintf("Number of opposite-treatment units within PS caliper = %.2f", caliper),
       y = "Count",
       title = "How many close matches exist? (caliper-based diagnostic)")
```

# 4. NN distance vs IPW weights

```{r}
plot_df <- bind_rows(
  turn %>% mutate(dataset = "Original"),
  turn_bad %>% mutate(dataset = "Near-deterministic")
) %>%
  mutate(no_close = (n_close == 0))

ggplot(plot_df, aes(x = nn_psdist, y = w_ate, shape = no_close, color = dataset)) +
  geom_point(alpha = 0.5) +
  scale_y_log10() +
  theme_minimal() +
  labs(
    x = "Nearest opposite-treatment PS distance",
    y = "IPW weight (log scale)",
    shape = "No close match",
    title = "Units with no close matches drive extreme IPW weights"
  )
```

